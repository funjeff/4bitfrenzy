package npcs;

import java.awt.Dimension;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;

import engine.GameObject;
import items.Item;
import network.NetworkHandler;

public class NPC extends GameObject implements ItemGenerator {
	
	private String npcType;
	private GameObject linkedQuestItem;
	
	private static HashMap<Integer, NPC> npcMap;
	
	private static HashMap<Class<?>, Class<?>> collisionExceptions = new HashMap<Class<?>, Class<?>> ();
	
	private static HashMap<Class<?>, Dimension> hitboxDimensions;
	
	protected NPC () {
		npcType = getClass ().getSimpleName ();
		initNpc ();
	}
	
	protected NPC (String type) {
		this.npcType = type;
		initNpc ();
	}
	
	protected NPC (double x, double y) {
		npcType = getClass ().getSimpleName ();
		setX (x);
		setY (y);
		initNpc ();
	}
	
	protected NPC (String type, double x, double y) {
		npcType = type;
		setX (x);
		setY (y);
		initNpc ();
	}
	
	public void initNpc () {
		System.out.println (getClass ());
		if (NetworkHandler.isHost ()) {
			declare ((int)getX (), (int)getY ());
			NetworkHandler.getServer ().sendMessage ("NPC CREATE " + toString ());
		}
	}
	
	public static void initHitboxDimensions () {
		
		//Make the hitbox dimensions
		hitboxDimensions = new HashMap<Class<?>, Dimension> ();
		
		//Populate the hitbox dimensions
		hitboxDimensions.put (Dirt.class, new Dimension (30, 31));
		hitboxDimensions.put (Basketball.class, new Dimension (48, 48));
		
	}
	
	/**
	 * Makes a new instance of the NPC specified by the string s (in the format generated by toString())
	 * @param s the string containing the NPC parameters
	 * @return a new NPC with the type specified in s, with all the parameters specified in s
	 */
	public static NPC getInstance (String s) {
		String[] params = s.split (":");
		try {
			//Make and return a new NPC with the given parameters
			double sx = Double.parseDouble (params [2]);
			double sy = Double.parseDouble (params [3]);
			NPC newNpc = (NPC) Class.forName ("npcs." + params[0]).getConstructor (Double.TYPE, Double.TYPE).newInstance (sx, sy);
			newNpc.id = Integer.parseInt (params [1]);
			newNpc.updateNpc (s);
			return newNpc;
		} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
				| NoSuchMethodException | SecurityException | ClassNotFoundException e) {
			//Return null if instantiation fails
			e.printStackTrace();
			return null;
		}
	}
	
	/**
	 * Updates the parameters of this NPC to match the String s
	 * @param s the parameter string (of the format output by toString())
	 */
	public void updateNpc (String s) {
		String[] params = s.split (":");
		this.id = Integer.parseInt (params [1]);
		setX (Double.parseDouble (params [2]));
		setY (Double.parseDouble (params [3]));
	}
	
	/**
	 * Only call as host, updates position for clients
	 * @param y
	 */
	public void assertPosition (double x, double y) {
		setX (x);
		setY (y);
		NetworkHandler.getServer ().sendMessage ("NPC UPDATE " + toString ());
	}
	
	/**
	 * Gets the type of this NPC as a String
	 * @return this NPC's type
	 */
	public String getNpcType () {
		return npcType;
	}
	
	/**
	 * Use instead of frameEvent for NPC types
	 */
	public void npcFrame () {
		//Do nothing
	}
	
	public static NPC getNpcById (int id) {
		return npcMap.get (id);
	}
	
	protected void addCollisionException (Class c) {
		collisionExceptions.put (c, c);
	}
	
	public boolean canCollide (Class c) {
		if (!collisionExceptions.containsKey (c)) {
			return true;
		} else {
			return false;
		}
	}
	
	private void mapNpc () {
		if (npcMap == null) {
			npcMap = new HashMap<Integer, NPC> ();
		}
		npcMap.put (getId (), this);
	}
	
	public boolean spawnsQuestItem () {
		return false;
	}
	
	public Class<?> getQuestItemType () {
		return null;
	}
	
	public int getMinQuestItemDist () {
		return 2;
	}
	
	public int getMaxQuestItemDist () {
		return 5;
	}
	
	public double getQuestItemSpawnOdds () {
		return 1.0;
	}
	
	public int getMinQuestItems () {
		return 0;
	}
	
	public int getMaxQuestItems () {
		return 4;
	}
	
	public void linkQuestObject (GameObject questItem) {
		//Only present to prevent duplicate quest spawns
		this.linkedQuestItem = questItem;
	}
	
	public GameObject getLinkedQuestsItem () {
		return linkedQuestItem;
	}
	
	public static Dimension getHitboxDimensions (Class<?> c) {
		
		if (hitboxDimensions == null) {
			initHitboxDimensions ();
		}
		
		if (!hitboxDimensions.containsKey (c)) {
			return new Dimension (32, 32);
		} else {
			return hitboxDimensions.get (c);
		}
		
	}
	
	@Override
	public void declare () {
		declare ((int)getX (), (int)getY ());
		mapNpc ();
	}
	
	@Override
	public void declare (int x, int y) {
		if (!NetworkHandler.isHost ()) {
			int currId = id;
			super.declare (x, y);
			id = currId; //Hacky workaround to keep the old ID
		} else {
			super.declare (x, y);
		}
		mapNpc ();
	}
	
	@Override
	public void forget () {
		super.forget ();
		if (NetworkHandler.isHost ()) {
			NetworkHandler.getServer ().sendMessage ("NPC FORGET " + getId ());
		}
	}
	
	@Override
	public void frameEvent () {
		if (NetworkHandler.isHost ()) {
			npcFrame ();
		}
	}
	
	@Override
	public String toString () {
		//If overriding, append to super.toString()
		return getNpcType () + ":" + getId () + ":" + getX () + ":" + getY ();
	}
	
	@Override
	public void becomeItem (Class<?> c) {
		Item it;
		try {
			it = (Item)c.getConstructor ().newInstance ();
			it.declare ((int)getX (), (int)getY ());
		} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
				| NoSuchMethodException | SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		forget ();
	}

}
